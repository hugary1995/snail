<!doctype html>
<html lang="en">

<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

	<title>MOOSE Solid Mechanics Workshop</title>

	<link rel="stylesheet" href="dist/reset.css">
	<link rel="stylesheet" href="dist/reveal.css">
	<link rel="stylesheet" href="dist/theme/league.css">

	<!-- Theme used for syntax highlighted code -->
	<link rel="stylesheet" href="plugin/highlight/atom-one-dark.css">
	<link rel="stylesheet" href="style/custom.css">
</head>

<body>
	<div class="reveal">
		<div class="slides">
			<!--
      ##############################################################################
      Title page
      ##############################################################################
      -->
			<section>
				<h2 class="r-fit-text">MOOSE SOLID MECHANICS WORKSHOP</h2>
				<h3 style="text-align: center;">@ Duke University</h3>
				<p style="text-align: center;">March 11-12, 2024</p>
				<p style="text-align: center;">
					<a href="https://google.com">Slack workspace</a><br>
				</p>
				<p style="text-align: center;">
					<img data-src="assets/DOENE.png" alt="Department of Energy Office of Nuclear Energy"
						style="height: 110px; margin: 3rem auto auto auto; display: inline-block;">
					<img data-src="assets/NEAMS-with-tagline.png" alt="Nuclear Engineering Advanced Modeling and Simulation"
						style="height: 130px; margin: 3rem auto auto auto; display: inline-block;">
					<img data-src="assets/Argonnelablogo.png" alt="Argonne National Laboratory"
						style="height: 80px; margin: 3rem auto 2rem auto; display: inline-block;">
					<img data-src="assets/duke-pratt.jpeg" alt="Duke University Pratt School of Engineering"
						style="height: 120px; margin: 3rem auto auto 3rem; display: inline-block;">
				</p>
			</section>
			<!--
      ##############################################################################
      Intro
      ##############################################################################
      -->
			<section>
				<!--
				##############################################################################
				MOOSE
				##############################################################################
				-->
				<section>
					<h2>MOOSE</h2>
					<p style="text-align: center;">
						<span style="color: DodgerBlue">M</span>ultiphysics <span style="color: DodgerBlue">O</span>bject-<span
							style="color: DodgerBlue">O</span>riented <span style="color: DodgerBlue">S</span>imulation <span
							style="color: DodgerBlue">E</span>nvironment
					</p>
					<ul>
						<li>From a mathematical point of view: MOOSE is a <mark>Partial-Differential-Equation
								solver</mark>.</li>
						<li>From a software point of view: MOOSE is an extensible framework that integrates <mark>state-of-the-art
								scientific computing libraries</mark> for <mark>physics-based simulations</mark>.</li>
					</ul>
				</section>
				<!--
				##############################################################################
				Capabilities
				##############################################################################
				-->
				<section>
					<h2>MOOSE Capabilities</h2>
					<img data-src="assets/ecosystem.svg" style="height: 550px;">
				</section>
				<!--
				##############################################################################
				Why MOOSE
				##############################################################################
				-->
				<section>
					<h2>Why MOOSE?</h2>
					<ul>
						<li>MOOSE is built upon high-quality libraries and packages,<br>e.g., <a
								href="https://libmesh.github.io/">libMesh</a>, <a href="https://petsc.org/release/">PETSc</a>, <a
								href="https://code.ornl.gov/neams-workbench/wasp">WASP</a>, <a
								href="https://reverendbedford.github.io/neml2/">NEML2</a>, etc.
							<ul>
								<li>Scalability to over <mark>30,000 cores</mark></li>
								<li>Multiple <mark>R&D 100</mark> awards</li>
								<li>Wide variety of <a
										href="https://mooseframework.inl.gov/application_usage/tracked_apps.html">applications</a></li>
							</ul>
						</li>
						<li>MOOSE is chosen by the scientific computing community.
							<ul>
								<li>Over <mark>100 contributors</mark></li>
								<li>Over <mark>500 publications</mark></li>
								<li>Over <mark>10,000,000 tests</mark> run every week</li>
							</ul>
						</li>
					</ul>
				</section>
				<section>
					<img data-src="assets/platform.png" style="height: 400px;">
				</section>
			</section>
			<!--
			##############################################################################
			Install
			##############################################################################
			-->
			<section>
				<section>
					<h2>Installation</h2>
					<ul>
						<li>The complete installation guide is available on the <a
								href="https://mooseframework.inl.gov/getting_started/installation/index.html">MOOSE website</a>.</li>
						<li>Recommended installation method: <a
								href="https://mooseframework.inl.gov/getting_started/installation/conda.html">Conda</a>.
							<ul>
								<li>Suitable for both Linux and MacOS</li>
								<li>
									On Windows, first install the <a href="https://learn.microsoft.com/en-us/windows/wsl/install">Windows
										Subsystem for Linux (WSL)</a>,<br>
									then follow the <a
										href="https://mooseframework.inl.gov/getting_started/installation/conda.html">Conda</a> installation
									method.
								</li>
							</ul>
						</li>
					</ul>
					<blockquote style="text-align: left; font-size: x-large;">If you run into any issue during the installation
						process, please feel free to ask for help in the installation channel of the Slack workspace.</blockquote>
				</section>
				<section>
					<p>Install Conda</p>
					<p style="text-align: left; font-size: 1rem;">
						Linux users: replace <mark>XXX</mark> with <mark>Linux-x86_64</mark><br>
						Mac (Intel) users: replace <mark>XXX</mark> with <mark>MacOSX-x86_64</mark><br>
						Mac (Apple Silicon) users: replace <mark>XXX</mark> with <mark>MacOSX-arm64</mark>
					</p>
					<pre class="shell" style="margin-left: 0;"><code data-trim data-noescape>
						curl -L -O https://github.com/conda-forge/miniforge/releases/latest/download/Miniforge3-XXX.sh
						bash Miniforge3-*.sh -b -p ~/miniforge
						~/miniforge/bin/conda init --all
					</code></pre>
					<p>Create environment</p>
					<pre class="shell" style="margin-left: 0;"><code data-trim data-noescape>
						conda create -n moose
						conda activate moose
						conda install -c https://conda.software.inl.gov/public moose-dev
					</code></pre>
					<p>Install MOOSE</p>
					<pre class="shell" style="margin-left: 0;"><code data-trim data-noescape>
						mkdir -p ~/projects
						cd ~/projects
						git clone --single-branch -b master --depth 1 https://github.com/idaholab/moose.git
						cd moose/test
						make -j N
					</code></pre>
				</section>
			</section>
			<!--
			##############################################################################
			Framework
			##############################################################################
			-->
			<section>
				<section>
					<h2>Framework Overview</h2>
					<div class="cozy">
						<ul>
							<li><mark>All modules and apps</mark> are built upon the MOOSE <mark>framework level capabilities</mark>.
							</li>
							<li>The Solid Mechanics module is no exception.</li>
							<li>Here, we will only go over a <mark>bare minimum</mark> amount of
								framework
								level
								capabilities.</li>
							<table>
								<thead>
									<tr>
										<th>System/Syntax</th>
										<th>Description</th>
									</tr>
								</thead>
								<tbody>
									<tr>
										<td><a href="https://mooseframework.inl.gov/syntax/Mesh/index.html">[Mesh]</a></td>
										<td>Defines the partition of the physical domain where the problem is defined</td>
									</tr>
									<tr>
										<td><a href="https://mooseframework.inl.gov/syntax/Variables/index.html">[Variables]</a></td>
										<td>Declares unknown variables and their corresponding function spaces</td>
									</tr>
									<tr>
										<td><a href="https://mooseframework.inl.gov/syntax/Kernels/index.html">[Kernels]</a></td>
										<td>Defines the partial differential equations that describe the problem of interest</td>
									</tr>
									<tr>
										<td><a href="https://mooseframework.inl.gov/syntax/BCs/index.html">[BCs]</a> <a
												href="https://mooseframework.inl.gov/syntax/ICs/index.html">[ICs]</a></td>
										<td>Defines boundary/initial conditions of the problem</td>
									</tr>
									<tr>
										<td><a href="https://mooseframework.inl.gov/syntax/Executioner/index.html">[Executioner]</a></td>
										<td>Configures how the problem is solved</td>
									</tr>
									<tr>
										<td><a href="https://mooseframework.inl.gov/syntax/Outputs/index.html">[Outputs]</a></td>
										<td>Informs MOOSE what, where, when, and how to output</td>
									</tr>
								</tbody>
							</table>
						</ul>
					</div>
				</section>
				<!--
				##############################################################################
				Tutorial 0: How MOOSE works
				##############################################################################
				-->
				<section>
					<div class="container" style="grid-template-columns: 30% 40% 30%;">
						<div class="col">
							<h4 style="text-align: left">Problem description</h4>
							<img data-src="assets/tutorial00.png" style="height: 400px;">
						</div>
						<div class="col">
							<h4 style="text-align: left">MOOSE input file</h4>
							<pre class="python" style="width: 60%; margin-left: 0;">
								<code data-trim data-noescape>
								[GlobalParams]
									displacements = 'disp_x disp_y'
								[]

								[Mesh]
									[sample]
										type = FileMeshGenerator
										file = '../gold/sample.msh'
									[]
									uniform_refine = 1
								[]

								[Physics]
									[SolidMechanics]
										[QuasiStatic]
											[sample]
												new_system = true
												add_variables = true
												strain = FINITE
												formulation = TOTAL
												volumetric_locking_correction = true
												generate_output = "cauchy_stress_xx cauchy_stress_yy cauchy_stress_zz
																					 cauchy_stress_xy cauchy_stress_xz cauchy_stress_yz
																					 mechanical_strain_xx mechanical_strain_yy mechanical_strain_zz
																					 mechanical_strain_xy mechanical_strain_xz mechanical_strain_yz"
												additional_generate_output = 'vonmises_cauchy_stress'
											[]
										[]
									[]
								[]

								[BCs]
									[fix_x]
										type = DirichletBC
										variable = disp_x
										value = 0
										boundary = 'top bottom'
									[]
									[bottom_fix_y]
										type = DirichletBC
										variable = disp_y
										value = 0
										boundary = 'bottom'
									[]
									[top_pull_y]
										type = FunctionDirichletBC
										variable = disp_y
										function = 't'
										boundary = 'top'
									[]
								[]

								[Materials]
									[neo_hookean]
										type = ComputeNeoHookeanStress
										lambda = 4000
										mu = 6700
									[]
								[]

								[Executioner]
									type = Transient
									solve_type = NEWTON
									petsc_options_iname = '-pc_type'
									petsc_options_value = 'lu'
									automatic_scaling = true
									end_time = 2
									dt = 0.02
								[]

								[Outputs]
									exodus = true
								[]
								</code>
							</pre>
						</div>
						<div class="col">
							<h4 style="text-align: left">Result</h4>
							<video controls style="height: 500px; margin: auto; display: inline-block;">
								<source data-src="/assets/tutorial00.webm" type="video/webm" />
							</video>
						</div>
					</div>
				</section>
			</section>
			<!--
			##############################################################################
			Theory
			##############################################################################
			-->
			<section>
				<h2>Theory: Balance of Linear Momentum</h2>
				<p>Starting from the <mark>strong form</mark></p>
				\[\begin{aligned}
				- \sigma_{ij,j} = 0, \quad \text{in } \Omega
				\end{aligned} \]
				<p>The corresponding <mark>weak form</mark> seeks
					displacements
					$u_i$ such that</p>
				\[\begin{aligned}
				\forall \phi_i: \quad - \int_\Omega \phi_i \sigma_{ij,j}\ \mathrm{d}V = 0
				\end{aligned} \]
				<p>Applying the <a href="https://en.wikipedia.org/wiki/Divergence_theorem">divergence
						theorem</a>, we get</p>
				\[\begin{aligned}
				\forall \phi_i: \quad \int_\Omega \phi_{i,j} \sigma_{ij}\ \mathrm{d}V - \int_{\partial\Omega} \phi_i
				t_i\ \mathrm{d}A = 0
				\end{aligned} \]
				<p><mark>Material models</mark> relate the
					primary unknown, i.e.,
					<mark>displacements</mark> $u_i$, to the thermodynamic force, i.e.,
					<mark>Cauchy stress</mark> $\sigma_{ij}$.
				</p>
			</section>
			<!--
			##############################################################################
			Tutorial 01: Linear Elastic Material
			##############################################################################
			-->
			<section>
				<section>
					<h2>Tutorial 01: Linear Elastic Material</h2>
					<p>The <mark>material model</mark> for a linear elastic material is</p>
					\[\begin{aligned}
					\sigma_{ij} &amp;= \lambda \varepsilon_{kk} \delta_{ij} + 2 \mu \varepsilon_{ij} \\
					\varepsilon_{ij} &amp;= \frac{1}{2} (u_{i,j} + u_{j,i})
					\end{aligned} \]
					<p>As a reminder: The <mark>weak form</mark> for linear momentum balance is</p>
					\[\begin{aligned}
					\forall \phi_i: \quad \int_\Omega \phi_{i,j} \sigma_{ij}\ \mathrm{d}V = 0
					\end{aligned} \]
					<p>Let's implement this in MOOSE!</p>
				</section>
				<section>
					<p>The C++ source code closely resembles the equations:</p>

					<p style="text-align: left; font-size: x-large;">
						$\varepsilon_{ij} = \frac{1}{2} (u_{i,j} + u_{j,i})$
					</p>
					<pre class="cpp" style="margin-left: 0;"><code data-trim data-noescape>
					auto e = SR2::initializeSymmetric((*_grad_u[0])[_qp], (*_grad_u[1])[_qp], (*_grad_u[2])[_qp]);
					</code></pre>

					<p style="text-align: left; font-size: x-large;">
						$\sigma_{ij} = \lambda \varepsilon_{kk} \delta_{ij} + 2 \mu \varepsilon_{ij}$
					</p>
					<pre class="cpp" style="margin-left: 0;"><code data-trim data-noescape>
					auto s = _lambda[_qp] * e.trace() * SR2::identity() + 2 * _mu[_qp] * e;
					</code></pre>

					<p style="text-align: left; font-size: x-large;">
						$\phi_{i,j} \sigma_{ij}$
					</p>
					<pre class="cpp" style="margin-left: 0;"><code data-trim data-noescape>
					auto r = _grad_test[_i][_qp] * s.row(_component);
					</code></pre>
				</section>
				<section>
					<div class="container" style="grid-template-columns: 60% 40%;">
						<div class="col">
							<p>Input file walkthrough</p>
							<pre class="python" style="margin-left: 0;">
								<code data-trim data-noescape>
								[GlobalParams]
									displacements = 'disp_x disp_y'
								[]

								[Mesh]
									[sample]
										type = FileMeshGenerator
										file = '../gold/sample.msh'
									[]
								[]

								[Variables]
									[disp_x]
									[]
									[disp_y]
									[]
								[]

								[Kernels]
									[momentum_balance_x]
										type = Tutorial01Kernel
										variable = disp_x
										lambda = 4000
										mu = 6700
										component = 0
									[]
									[momentum_balance_y]
										type = Tutorial01Kernel
										variable = disp_y
										lambda = 4000
										mu = 6700
										component = 1
									[]
								[]

								[BCs]
									[fix_x]
										type = DirichletBC
										variable = disp_x
										value = 0
										boundary = 'top bottom'
									[]
									[bottom_fix_y]
										type = DirichletBC
										variable = disp_y
										value = 0
										boundary = 'bottom'
									[]
									[top_pull_y]
										type = FunctionDirichletBC
										variable = disp_y
										function = 't'
										boundary = 'top'
									[]
								[]

								[Executioner]
									type = Transient
									solve_type = NEWTON
									petsc_options_iname = '-pc_type'
									petsc_options_value = 'lu'
									automatic_scaling = true
									end_time = 2
									dt = 0.2
								[]

								[Outputs]
									exodus = true
								[]
								</code>
							</pre>
						</div>
						<div class="col">
							<img data-src="assets/tutorial00.png" style="height: 500px;">
						</div>
					</div>
				</section>
				<section>
					<p>To solve the problem in <mark>serial</mark>:</p>
					<pre class="shell" style="margin-left: 0;">
						<code data-trim data-noescape>
							~/projects/snail-opt -i tension.i
						</code>
					</pre>
					<p>To solve the problem in <mark>parallel</mark>:</p>
					<pre class="shell" style="margin-left: 0;">
						<code data-trim data-noescape>
							mpiexec -n 2 ~/projects/snail/snail-opt -i tension.i
						</code>
					</pre>
					<p><a href="https://www.paraview.org/download/">ParaView</a> is the recommended tool
						for <mark>visualization</mark> purposes:</p>
					<pre class="shell" style="margin-left: 0;">
						<code data-trim data-noescape>
							paraview tension_out.e
						</code>
					</pre>
				</section>
			</section>
			<!--
			##############################################################################
			Tutorial 02: Modular Material Modeling
			##############################################################################
			-->
			<section>
				<section>
					<h2>Tutorial 02: Modular Material Modeling</h2>
					<ul>
						<li><code>Tutorial01Kernel.C</code> has demonstrated an elegant resemblance between MOOSE source code and
							mathematical equations.</li>
						<li>Two places to <mark>improve</mark>:
							<ul>
								<li><code>Tutorial01Kernel.C</code> only works for linear elastic materials.<br>
									<mark>Can we generalize it to work for <em>any</em> material?</mark>
								</li>
								<li>At each quadrature point, the <code>computeQpResidual</code> method is called twice (3 times in
									3D).<br>
									<mark>Can we avoid the redundant computations of strain and stress?</mark>
								</li>
							</ul>
						</li>
						<li class="fragment">Yes &mdash; with the <mark><code>[Materials]</code></mark>
							system.</li>
					</ul>
				</section>
				<section>
					<div class="container" style="grid-template-columns: 50% 50%;">
						<div class="col">
							<p>Tutorial 01 source code</p>
							<pre class="cpp" style="width: 75%; margin-left: 0;">
								<code data-trim data-noescape>
									ADReal
									Tutorial01Kernel::computeQpResidual()
									{
										using SR2 = ADSymmetricRankTwoTensor;

										// Calculate strain from displacement gradients
										auto e = SR2::initializeSymmetric((*_grad_u[0])[_qp], (*_grad_u[1])[_qp], (*_grad_u[2])[_qp]);

										// Calculate stress from strain and material constants
										auto s = _lambda[_qp] * e.trace() * SR2::identity() + 2 * _mu[_qp] * e;

										// Calculate residual
										auto r = _grad_test[_i][_qp] * s.row(_component);

										return r;
									}
								</code>
							</pre>
						</div>
						<div class="col">
							<p>Tutorial 02 source code</p>
							<pre class="cpp" style="width: 75%; margin-left: 0;">
								<code data-trim data-noescape>
									void
									Tutorial02Strain::computeQpProperties()
									{
										using SR2 = ADSymmetricRankTwoTensor;

										_e[_qp] = SR2::initializeSymmetric((*_grad_u[0])[_qp], (*_grad_u[1])[_qp], (*_grad_u[2])[_qp]);
									}
								</code>
							</pre>
							<pre class="cpp" style="width: 75%; margin-left: 0;">
								<code data-trim data-noescape>
									void
									Tutorial02Stress::computeQpProperties()
									{
										using SR2 = ADSymmetricRankTwoTensor;

										_s[_qp] = _lambda[_qp] * _e[_qp].trace() * SR2::identity() + 2 * _mu[_qp] * _e[_qp];
									}
								</code>
							</pre>
							<pre class="cpp" style="width: 75%; margin-left: 0;">
								<code data-trim data-noescape>
									ADReal
									Tutorial02Kernel::computeQpResidual()
									{
										return _grad_test[_i][_qp] * _s[_qp].row(_component);
									}
								</code>
							</pre>
						</div>
					</div>
				</section>
				<section>
					<div class="container" style="grid-template-columns: 50% 50%;">
						<div class="col">
							<p>Tutorial 01 input file</p>
							<pre class="python" style="width: 75%; margin-left: 0;">
								<code data-trim data-noescape>
								[Kernels]
									[momentum_balance_x]
										type = Tutorial01Kernel
										variable = disp_x
										lambda = 4000
										mu = 6700
										component = 0
									[]
									[momentum_balance_y]
										type = Tutorial01Kernel
										variable = disp_y
										lambda = 4000
										mu = 6700
										component = 1
									[]
								[]
								</code>
							</pre>
						</div>
						<div class="col">
							<p>Tutorial 02 input file</p>
							<pre class="python" style="width: 75%; margin-left: 0;">
								<code data-trim data-noescape>
								[Kernels]
									[momentum_balance_x]
										type = Tutorial02Kernel
										variable = disp_x
										component = 0
									[]
									[momentum_balance_y]
										type = Tutorial02Kernel
										variable = disp_y
										component = 1
									[]
								[]

								[Materials]
									[strain]
										type = Tutorial02Strain
									[]
									[stress]
										type = Tutorial02Stress
										lambda = 4000
										mu = 6700
									[]
								[]
								</code>
							</pre>
						</div>
					</div>
				</section>
			</section>
			<!--
			##############################################################################
			Tutorial 03: Postprocessing FAQ
			##############################################################################
			-->
			<section>
				<section data-auto-animate>
					<h2>Tutorial 03: Postprocessing FAQ</h2>
					<p><strong>Q</strong>: How do I output <mark>tensorial
							quantities</mark>, e.g., strain and stress,
						<mark>at every point</mark>?
					</p>
					<p><strong>A</strong>: Use <mark><code>[AuxVariables]</code></mark> and
						<mark><code>[AuxKernel]</code></mark>.
					</p>
					<pre class="python" style="margin-left: 0;">
						<code data-trim data-noescape>
						[Materials]
							[stress_yy]
								type = ADSymmetricRankTwoCartesianComponent
								tensor = stress
								property_name = stress_yy
								index_i = 1
								index_j = 1
							[]
						[]

						[AuxVariables]
							[stress_yy]
								order = CONSTANT
								family = MONOMIAL
								[AuxKernel]
									type = ADMaterialRealAux
									property = stress_yy
								[]
							[]
						[]
						</code>
					</pre>
				</section>
				<section data-auto-animate>
					<h2>Tutorial 03: Postprocessing FAQ</h2>
					<p><strong>Q</strong>: How do I output <mark>tensorial
							quantities</mark>, e.g., strain and stress,
						<mark>at a specific point</mark>?
					</p>
					<p><strong>A</strong>: Use the <mark><code>PointValue</code></mark> postprocessor.
					</p>
					<pre class="python" style="margin-left: 0;">
						<code data-trim data-noescape>
						[Materials]
							[stress_yy]
								type = ADSymmetricRankTwoCartesianComponent
								tensor = stress
								property_name = stress_yy
								index_i = 1
								index_j = 1
							[]
						[]

						[AuxVariables]
							[stress_yy]
								order = CONSTANT
								family = MONOMIAL
								[AuxKernel]
									type = ADMaterialRealAux
									property = stress_yy
								[]
							[]
						[]

						[Postprocessors]
							[stress_yy_center]
								type = PointValue
								variable = stress_yy
								point = '5 5 0'
							[]
						[]
						</code>
					</pre>
				</section>
				<section data-auto-animate>
					<h2>Tutorial 03: Postprocessing FAQ</h2>
					<p><strong>Q</strong>: How do I output <mark>tensorial
							quantities</mark>, e.g., strain and stress,
						<mark>averaged over the entire domain</mark>?
					</p>
					<p><strong>A</strong>: Use the
						<mark><code>ADElementAverageMaterialProperty</code></mark>
						postprocessor.
					</p>
					<pre class="python" style="margin-left: 0;">
						<code data-trim data-noescape>
						[Materials]
							[stress_yy]
								type = ADSymmetricRankTwoCartesianComponent
								tensor = stress
								property_name = stress_yy
								index_i = 1
								index_j = 1
							[]
						[]

						[Postprocessors]
							[avg_stress_yy]
								type = ADElementAverageMaterialProperty
								mat_prop = stress_yy
							[]
						[]
						</code>
					</pre>
				</section>
				<section data-auto-animate>
					<h2>Tutorial 03: Postprocessing FAQ</h2>
					<p><strong>Q</strong>: How do I output the <mark>average
							displacement along a boundary?</mark>
					</p>
					<p><strong>A</strong>: Use the <mark><code>SideAverageValue</code></mark>
						postprocessor.
					</p>
					<pre class="python" style="margin-left: 0;">
						<code data-trim data-noescape>
						[Postprocessors]
							[displacement]
								type = SideAverageValue
								variable = disp_y
								boundary = 'top'
							[]
						[]
						</code>
					</pre>
				</section>
				<section data-auto-animate>
					<h2>Tutorial 03: Postprocessing FAQ</h2>
					<p><strong>Q</strong>: How do I output the <mark>total
							reaction force</mark> on a boundary?
					</p>
					<p><strong>A</strong>: Use the <mark><code>save_in</code></mark> option and the
						<mark><code>NodalSum</code></mark> postprocessor.
					</p>
					<pre class="python" style="margin-left: 0;">
						<code data-trim data-noescape>
						[AuxVariables]
							[r_x]
							[]
							[r_y]
							[]
						[]

						[Kernels]
							[momentum_balance_x]
								type = Tutorial02Kernel
								variable = disp_x
								component = 0
								save_in = 'r_x'
							[]
							[momentum_balance_y]
								type = Tutorial02Kernel
								variable = disp_y
								component = 1
								save_in = 'r_y'
							[]
						[]

						[Postprocessors]
							[force]
								type = NodalSum
								variable = r_y
								boundary = 'top'
							[]
						[]
						</code>
					</pre>
				</section>
			</section>
			<!--
			##############################################################################
			Tutorial 04: The Solid Mechanics [Physics]
			##############################################################################
			-->
			<section>
				<section>
					<h2>Tutorial 04: The Solid Mechanics [Physics]</h2>
					<ul>
						<li>So far, we have created from scratch <em>our own</em> "solid mechanics module" in
							<code>snail</code>.
						</li>
						<li>Now, we are ready to learn what the <mark>MOOSE Solid Mechanics module</mark> can do for us.
							<ul>
								<li>Automatic creation of variables, kernels, and strain calculators</li>
								<li>Simplified tensor outputting</li>
								<div class="fragment semi-fade-out">
									<li>Small and large deformation (both hypoelasticity and hyperelasticity) kinematics</li>
									<li>Stabilization to alleviate volumetric locking</li>
									<li>A collection of common material models</li>
									<li>Many other advanced features such as homogenization, fracture integrals, CZM, etc.</li>
								</div>
							</ul>
						</li>
						<li class="fragment">The canonical entry point for the MOOSE Solid Mechanics module is
							<mark><code>[Physics/SolidMechanics]</code></mark>.
						</li>
					</ul>
				</section>
				<section>
					<p>Input file walkthrough</p>
					<pre class="python" style="margin-left: 0;">
						<code data-trim data-noescape>
						[GlobalParams]
							displacements = 'disp_x disp_y'
						[]

						[Mesh]
							[sample]
								type = FileMeshGenerator
								file = '../gold/sample.msh'
							[]
						[]

						[Physics]
							[SolidMechanics]
								[QuasiStatic]
									[sample]
										new_system = true
										add_variables = true
										strain = SMALL
										formulation = TOTAL
										generate_output = "cauchy_stress_xx cauchy_stress_yy cauchy_stress_zz
																			 cauchy_stress_xy cauchy_stress_xz cauchy_stress_yz
																			 mechanical_strain_xx mechanical_strain_yy mechanical_strain_zz
																			 mechanical_strain_xy mechanical_strain_xz mechanical_strain_yz"
										additional_generate_output = 'vonmises_cauchy_stress'
									[]
								[]
							[]
						[]

						[Materials]
							[elasticity_tensor]
								type = ComputeIsotropicElasticityTensor
								lambda = 4000
								shear_modulus = 6700
							[]
							[stress]
								type = ComputeLagrangianLinearElasticStress
							[]
						[]

						[BCs]
							[fix_x]
								type = DirichletBC
								variable = disp_x
								value = 0
								boundary = 'top bottom'
							[]
							[bottom_fix_y]
								type = DirichletBC
								variable = disp_y
								value = 0
								boundary = 'bottom'
							[]
							[top_pull_y]
								type = FunctionDirichletBC
								variable = disp_y
								function = 't'
								boundary = 'top'
							[]
						[]

						[Executioner]
							type = Transient
							solve_type = NEWTON
							petsc_options_iname = '-pc_type'
							petsc_options_value = 'lu'
							automatic_scaling = true
							end_time = 2
							dt = 0.2
						[]

						[Outputs]
							exodus = true
						[]
						</code>
					</pre>
				</section>
			</section>
			<!--
			##############################################################################
			Tutorial 05: Large Deformation
			##############################################################################
			-->
			<section>
				<section>
					<h2>Tutorial 05: Large Deformation</h2>
					<ul>
						<li>The Solid Mechanics module makes switching between kinematics a trivial task.
							<ul>
								<li>Small deformation: <mark><code>strain = SMALL</code></mark></li>
								<li>Large deformation: <mark><code>strain = FINITE</code></mark></li>
							</ul>
						</li>
						<li>The large deformation formulation comes with two flavors:
							<ul>
								<li>
									<mark>Hypoelasticity</mark>: small strain material model integrated objectively
									\[
									\begin{aligned}
									\mathring{\sigma}_{ij} = \dot{\sigma}_{ij} - Q_{ik}\sigma_{kj} - \sigma_{ik}Q_{jk} + Q_{kk}\sigma_{ij}
									\end{aligned}
									\]
								</li>
								<li>
									<mark>Hyperelasticity</mark>: derived from a strain energy density function
									\[
									\begin{aligned}
									\sigma_{ij} = \frac{1}{J} P_{iJ} F_{jJ}, \quad P_{iJ} = \frac{\partial w}{\partial F_{iJ}}
									\end{aligned}
									\]
								</li>
							</ul>
						</li>
					</ul>
				</section>
				<section>
					<p>Let us compare 6 elastic material models:</p>
					<div class="container" style="grid-template-columns: 50% 50%;">
						<div class="col">
							<div class="cozy">
								<ol style="font-size: xx-large;">
									<li>Small deformation, <mark><code>ComputeLagrangianLinearElasticStress</code></mark>
										\[
										\begin{aligned}
										\sigma_{ij} = C_{ijkl} \varepsilon_{kl}
										\end{aligned}
										\]
									</li>
									<li>Large deformation, hyperelastic, <em>St. Venant-Kirchhoff</em>,
										<mark><code>ComputeStVenantKirchhoffStress</code></mark>
										\[
										\begin{aligned}
										\sigma_{ij} = \frac{1}{J}F_{iI}S_{IJ}F_{jJ}, \quad S_{IJ} = C_{IJKL} E_{KL}
										\end{aligned}
										\]
									</li>
									<li>Large deformation, hyperelastic, <em>Neo-Hookean</em>,
										<mark><code>ComputeNeoHookeanStress</code></mark>
										\[
										\begin{aligned}
										\sigma_{ij} = \frac{1}{J}F_{iI}S_{IJ}F_{jJ}, \quad S_{IJ} = \left(\lambda \log J - \mu\right)
										C^{-1}_{IJ}
										+ \mu \delta_{IJ}, \quad C_{IJ} = 2 E_{IJ} + \delta_{IJ}
										\end{aligned}
										\]
									</li>
								</ol>
							</div>
						</div>
						<div class="col">
							<div class="cozy">
								<ol start="4" style="font-size: xx-large;">
									<li>Large deformation, hypoelastic, <em>Trusdell</em> rate,
										<mark><code>objective_rate = truesdell</code></mark>
										\[
										\begin{align}
										Q_{ik} = l_{ik}
										\end{align}
										\]
									</li>
									<li>Large deformation, hypoelastic, <em>Jaumann</em> rate,
										<mark><code>objective_rate = jaumann</code></mark>
										\[
										\begin{align}
										Q_{ik} = w_{ik}, \quad w_{ik}=\frac{1}{2}\left(l_{ik}-l_{ki}\right)
										\end{align}
										\]
									</li>
									<li>Large deformation, hypoelastic, <em>Green-Naghdi</em> rate,
										<mark><code>objective_rate = green_naghdi</code></mark>
										\[
										\begin{align}
										Q_{ik} = \Omega_{ik} = \dot{R}_{ij} R_{kj}.
										\end{align}
										\]
									</li>
								</ol>
							</div>
						</div>
					</div>
				</section>
				<section>
					<img data-src="assets/large_deformation.svg" style="height: 600px;">
				</section>
				<section>
					<h3>Remarks</h3>
					<ul>
						<li>Choosing the suitable model for a material is essentially a matter of <mark>calibration</mark>.</li>
						<li>Advantages of <mark>hyperelastic</mark> formulations:
							<ul>
								<li>Coercivity and polyconvexity ensure existence and uniqueness of the solution.</li>
								<li>Integration error is negligible.</li>
							</ul>
						</li>
						<li>Advantages of <mark>hypoelastic</mark> formulations:
							<ul>
								<li>Small deformation models can be objectively integrated to solve large deformation problems.</li>
								<li>Many common engineering materials have been calibrated.</li>
							</ul>
						</li>
					</ul>
					<blockquote style="font-size: x-large;">See <a
							href="https://mooseframework.inl.gov/source/materials/lagrangian/ComputeLagrangianObjectiveStress.html">this
							page</a> for known limitations of hypoelastic formulations and some recommendations.</blockquote>
				</section>
			</section>
			<!--
			##############################################################################
			Tutorial 06: Coordinate Systems and Planar Formulations
			##############################################################################
			-->
			<section>
				<section>
					<h3>Tutorial 06: Coordinate Systems and Planar Formulations</h3>
					<p>The Solid Mechanics module supports three <mark>coordinate systems</mark>:
					<ul>
						<li><mark>Cartesian</mark> coordinate system, <mark><code>coord_type = XYZ</code></mark>
							<ul>
								<li>3D</li>
								<li>2D: plane strain (default)</li>
								<li>2D: plane stress</li>
								<li>2D: generalized plane strain</li>
							</ul>
						</li>
						<li><mark>Axisymmetric cylindrical</mark> coordinate system, <mark><code>coord_type = RZ</code></mark></li>
						<li><mark>Centrosymmetric spherical</mark> coordinate
							system, <mark><code>coord_type = RSpherical</code></mark></li>
					</ul>
					</p>
				</section>
				<section>
					<img data-src="assets/planar.png" style="height: 250px;">
					<img data-src="assets/planar.svg" style="height: 350px;" class="fragment">
				</section>
				<section>
					<div class="container" style="grid-template-columns: 30% 30% 40%;">
						<div class="col">
							<img data-src="assets/cylindrical_3D.png" style="height: 400px;">
						</div>
						<div class="col">
							<img data-src="assets/cylindrical_RZ.png" style="height: 400px;">
						</div>
						<div class="col fragment">
							<img data-src="assets/cylindrical.svg" style="height: 400px;">
						</div>
					</div>
				</section>
			</section>
			<!--
			##############################################################################
			Break
			##############################################################################
			-->
			<section>
				<h3><img data-src="assets/break.png"
						style="height: 80px; display: inline-block; margin: auto 20px auto auto">Break
				</h3>
				<ul>
					<li>This concludes the <mark>fundamentals</mark> of the MOOSE Solid Mechanics module.</li>
					<li>Coming up next
						<ul>
							<li>Advanced features
								<ul>
									<li>Volumetric locking correction (stablization)</li>
									<li>Dynamics</li>
									<li>Homogenization</li>
									<li>Plasticity</li>
									<li>Cohesive Zone Method</li>
								</ul>
							</li>
							<li>More advanced features</li>
							<li>Custom material model</li>
						</ul>
					</li>
				</ul>
			</section>
			<!--
			##############################################################################
			Tutorial 07: Volumetric Locking Correction (Stabilization)
			##############################################################################
			-->
			<section>
				<section>
					<h2>Tutorial 07: Volumetric Locking Correction</h2>
					<ul>
						<li>Standard 2D and 3D finite elements using a <mark>linear</mark> interpolation of the displacement field
							are <mark>not stable</mark>
							for <mark>incompressible</mark> and <mark>nearly incompressible</mark> deformation <span
								class="tooltip">Hughes (1987)
								<span class="tooltiptext" style="margin-left: -500px;">T. J. R Hughes. The Finite Element Method, Linear
									Static and Dynamic Finite
									Element Analysis. New Jersey:Prentice-Hall, 1987.</span>
							</span>.
						</li>
						<li>Two common methods:
							<ul>
								<li>The $\bar{F}$ approach <span class="tooltip">Souza Neto et al. (1996)
										<span class="tooltiptext" style="margin-left: -200px;">EA de Souza Neto, D Perić, M Dutko, and DRJ
											Owen. Design of simple low order finite elements for large strain analysis of nearly
											incompressible solids. International Journal of Solids and Structures, 33(20-22):3277–3296,
											1996.</span></span> modifies the strain definition
									\[
									\begin{aligned}
									\varepsilon'_{ij} = \varepsilon_{ij} + \frac{1}{3}(\bar{\varepsilon}_{kk} -
									\varepsilon_{kk})\delta_{ij}, \quad \bar{\varepsilon}_{ij} = \frac{1}{V^e}\int_{\Omega^e}
									\varepsilon_{ij}\ \mathrm{d}V
									\end{aligned}
									\]
								</li>
								<li>The $\bar{B}$ approach <span class="tooltip"> Hughes (1980)
										<span class="tooltiptext" style="margin-left: -200px;">Thomas JR Hughes. Generalization of selective
											integration procedures to anisotropic and nonlinear media. International Journal for Numerical
											Methods in Engineering, 15(9):1413–1418, 1980.</span></span> additionally modifies the trial
									strain
									\[
									\begin{aligned}
									\phi'_{i,j} = \phi_{i,j} + \frac{1}{3}(\bar{\phi}_{k,k} -
									\phi_{k,k})\delta_{ij}, \quad \bar{\phi}_{i,j} = \frac{1}{V^e}\int_{\Omega^e}
									\phi_{i,j}\ \mathrm{d}V
									\end{aligned}
									\]
								</li>
							</ul>
						</li>
						<li>The Solid Mechanics module implements <mark>the $\bar{F}$ approach.</mark></li>
						<li>To turn on stabilization, simply set <mark><code>volumetric_locking_correction = true</code></mark></li>
					</ul>
				</section>
				<section>
					<p>Cook's membrane</p>
					<div class="container" style="grid-template-columns: 50% 50%;">
						<div class="col">
							<img data-src="assets/cook.svg" style="height: 400px;">
						</div>
						<div class="col fragment">
							<img data-src="assets/vlc.svg" style="height: 400px;">
						</div>
					</div>
				</section>
			</section>
			<!--
			##############################################################################
			Tutorial 08: Structural Dynamics
			##############################################################################
			-->
			<section>
				<section>
					<h2>Tutorial 08: Structural Dynamcis</h2>
					<ul>
						<li>
							The balance of linear momentum is extended to incorporate <mark>inertial effects</mark>
							\[
							\begin{aligned}
							\rho \ddot{u}_i + \zeta \dot{u}_i - \sigma_{ij,j} = 0
							\end{aligned}
							\]
						</li>
						<li>
							The Solid Mechanics module implements the
							<span class="tooltip">Newmark
								<span class="tooltiptext" style="margin-left: -300px;">
									N. M. Newmark. A method of computation for structural dynamics. Journal of Engineering Mechanics,
									85(EM3):67–94, 1959.
								</span>
							</span>
							,
							<span class="tooltip">Hilber-Hughes-Taylor (HHT)
								<span class="tooltiptext" style="margin-left: -500px;">
									T. J. R Hughes. The finite element method:Linear static and dynamic finite element analysis. Dover
									Publications, Mineola, NY, 2000.
								</span>
							</span>
							, and the explicit central difference time integration schemes.
						</li>
						<li>To include inertial effects, replace <mark><code>QuasiStatic</code></mark> with
							<mark><code>Dynamic</code></mark>.
						</li>
					</ul>
				</section>
				<section>
					<h3>The Newmark Method</h3>
					<ul>
						<li>The <mark>Newmark</mark> time discretization is parametrized by <mark>$\beta$</mark> and
							<mark>$\gamma$</mark>:
							\[
							\begin{align}
							\ddot{u}_i^{(1)} &= \frac{u_i^{(1)}-u_i^{(0)}}{\beta \Delta t^2} -
							\frac{\dot{u}_i^{(0)}}{\beta\Delta
							t} + \left(1-\frac{1}{2\beta}\right)\ddot{u}_i^{(0)} \\
							\dot{u}_i^{(1)} &= \dot{u}_i^{(0)} + (1-\gamma)\Delta t\ddot{u}_i^{(0)} + \gamma\Delta t
							\ddot{u}_i^{(1)}
							\end{align}
							\]
						</li>
						<blockquote style="font-size: large;">The superscripts $(\xi)$ denote the quantities evaluated at
							$t+\xi\Delta t$.</blockquote>
						<li>Commonly chosen parameters
							<ul>
								<li>$\beta = \frac{1}{4}$, $\gamma = \frac{1}{2}$: The Newmark method is <mark>unconditionally
										stable</mark>.<br>
									&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;Also known as the constant average acceleration method.</li>
								<li>$\beta = \frac{1}{6}$, $\gamma = \frac{1}{2}$: The linear acceleration method.</li>
								<li>$\beta = 0$, $\gamma = \frac{1}{2}$: Equivalent to the central difference method, though integrated
									implicitly.</li>
							</ul>
						</li>
					</ul>
				</section>
				<section>
					<h3>The HHT Method</h3>
					<ul>
						<li>The <mark>HHT</mark> time integration method additionally introduces <mark>numerical dissipation</mark>,
							controlled
							by
							<mark>$\alpha$</mark>, by modifying the momentum balance equation
							\[
							\begin{aligned}
							\rho \ddot{u}_i^{(1)} + \zeta \left[ (1-\alpha) \dot{u}_i^{(1)} + \alpha \dot{u}_i^{(0)} \right] -
							\left[ (1-\alpha) \sigma_{ij,j}^{(1)} + \alpha \sigma_{ij,j}^{(0)} \right] = 0
							\end{aligned}
							\]
						</li>
						<li>When parameters are chosen appropriately, i.e.
							\[
							\begin{aligned}
							0 \leq \alpha \leq \frac{1}{3}, \quad \beta = \frac{(1+\alpha)^2}{4}, \quad \gamma = \frac{1}{2} +
							\alpha,
							\end{aligned}
							\]
							the system is at least <mark>second-order accurate</mark> and <mark>unconditionally stable</mark>.
						</li>
					</ul>
				</section>
				<section>
					<h3>The Explicit Central Difference Method</h3>
					<blockquote style="font-size: large;">Currently, the explicit central difference time integrator is
						experimental.</blockquote>
					<ul>
						<li>The explicit <mark>central difference</mark> method applies the following discretization:
							\[
							\begin{align}
							\dot{u}_i &= \dfrac{1}{2 \Delta t} \left( u_i^{(1)} - u_i^{(-1)} \right) \\
							\ddot{u}_i &= \dfrac{1}{\Delta t^2} \left( u_i^{(1)} - 2 u_i^{(0)} + u_i^{(-1)} \right)
							\end{align}
							\]
						</li>
						<li>Note $u_i^{(1)}$ now only depends on $u_i^{(0)}$ and $u_i^{(-1)}$, hence the system is
							<mark>explicit</mark>.
						</li>
						<li>The <mark><code>CentralDifference</code></mark> time integrator offers 3 solve strategies
							<ul>
								<li><mark><code>consistent</code></mark>: Use the "full" mass matrix which requires a
									linear solve.</li>
								<li><mark><code>lumped</code></mark>: Use the "lumped" mass matrix with a DoF-wise
									inversion.</li>
								<li><mark><code>lump_preconditioned</code></mark>: Use the "lumped" mass matrix as the
									preconditioner for the linear solve.</li>
							</ul>
						</li>
					</ul>
				</section>
				<section>
					<h3>Hamming a 1D bar</h3>
					<div class="container" style="grid-template-columns: 50% 50%;">
						<div class="col fragment">
							<img data-src="assets/implicit.svg" style="height: 550px;">
						</div>
						<div class="col fragment">
							<img data-src="assets/explicit.svg" style="height: 550px;">
						</div>
					</div>
				</section>
			</section>
			<!--
			##############################################################################
			Tutorial 09: Homogenization Constraints
			##############################################################################
			-->
			<section>
				<section>
					<h2>Tutorial 09: Homogenization Constraints</h2>
					<ul>
						<li>To model micro- and mesoscale <mark>representative volume elements (RVEs)</mark>, it is often desired to
							apply
							constraints on <mark>RVE-averaged</mark> strain and/or stress as "boundary conditions".</li>
						<li>The Solid Mechanics module features the <mark>Homogenization</mark> system for such constraints.</li>
						<li>The theory largely follows from
							<span class="tooltip">
								Danielsson et al. (2002)
								<span class="tooltiptext" style="margin-left: -300px;">
									M Danielsson, DM Parks, and MC Boyce. Three-dimensional micromechanical modeling of voided polymeric
									materials. Journal of the Mechanics and Physics of Solids, 50(2):351–379, 2002.
								</span>
							</span>.
							<ul>
								<li>
									For small deformation, the constraints are of the type
									\[
									\begin{aligned}
									\hat{s}_{ij} = \frac{1}{V}\int_\Omega s_{ij}\ \mathrm{d}V, \quad \hat{\varepsilon}_{ij} =
									\frac{1}{V}\int_\Omega \varepsilon_{ij}\ \mathrm{d}V
									\end{aligned}
									\]
								</li>
								<li>
									For large deformation, the constraints are of the type
									\[
									\begin{aligned}
									\hat{P}_{iJ} = \frac{1}{V} \int_\Omega P_{iJ}\ \mathrm{d}V, \quad
									\hat{F}_{iJ} = \frac{1}{V}\int_\Omega F_{iJ} \ \mathrm{d}V.
									\end{aligned}
									\]
								</li>
							</ul>
						</li>
					</ul>
				</section>
				<section>
					<h3>More on the theory</h3>
					<ul>
						<li>The homogenization system introduces an additional <mark>affine displacement</mark> field
							\[
							\begin{aligned}
							u_i = u_i^\mu + u_i^M, \quad u_i^M = G_{iJ}^M X_J
							\end{aligned}
							\]
							<ul>
								<li>
									For small deformation, the macro gradient tensor $G_{iJ}^M$ is symmetric. For large deformation, it is
									not.
								</li>
								<li>
									The deformation gradient then follows as $F_{iJ} = \delta_{iJ}
									+ u_{i,J}^\mu + G_{iJ}$
								</li>
							</ul>
						</li>
						<li>The corresponding constraint residuals are defined as
							\[
							\begin{aligned}
							r_{iJ}^{(P)} = \int_\Omega (\hat{P}_{iJ} - \bar{P}_{iJ})\ \mathrm{d}V, \quad r_{iJ}^{(F)} = \int_\Omega
							(\hat{F}_{iJ} - \bar{F}_{iJ})\ \mathrm{d}V
							\end{aligned}
							\]
						</li>
					</ul>
				</section>
				<section>
					<h3>Input file syntax</h3>
					<ul>
						<li>The homogenization constraints can be imposed through the <code>[Physics/SolidMechanics]</code> syntax.
							<ul>
								<li><mark><code>constraint_types</code></mark> specifies the constraint types to impose for each
									stress/strain
									component.
									<ul>
										<li><mark><code>strain</code></mark> denotes a constraint on <em>strain</em> (small deformation) or
											<em>deformation gradient</em> (large deformation)
										</li>
										<li><mark><code>stress</code></mark> denotes a constraint on the <em>Cauchy stress</em> (small
											deformation)
											or the <em>first Piola-Kirchhoff stress</em> (large deformation)</li>
										<li><mark><code>none</code></mark> places no constraint on the corresponding component</li>
									</ul>
								</li>
								<li><mark><code>targets</code></mark> specifies the prescribed values for each constrained component.
								</li>
							</ul>
						</li>
					</ul>
					<blockquote style="font-size: x-large;">
						The constraints are always listed in the column-major convention.
					</blockquote>
				</section>
				<section data-auto-animate>
					<div class="container" style="grid-template-columns: 40% 30% 30%;">
						<div class="col" style="justify-items: center;">
							<p>An RVE made of 4 materials</p>
							<img data-src="assets/homogenization.svg" style="height: 280px;">
							<div style="font-size: 1.5rem;">
								\[
								\begin{aligned}
								F_{xx} &= 1 + 0.1 \sin(20 t) + 0.1 \cos(15 t)\\
								P_{xy} &= 100 \sin(13 t) + 150 \cos(9 t)\\
								F_{yx} &= 0\\
								P_{yy} &= -70 \sin(9 t) - 130 \cos(25 t)
								\end{aligned}
								\]
							</div>
						</div>
						<div class="col fragment">
							<img data-src="assets/Fxx.svg" style="height: 250px;">
							<img data-src="assets/Fyx.svg" style="height: 250px;">
						</div>
						<div class="col fragment">
							<img data-src="assets/Pxy.svg" style="height: 250px;">
							<img data-src="assets/Pyy.svg" style="height: 250px;">
						</div>
					</div>
				</section>
				<section data-auto-animate>
					<div class="container" style="grid-template-columns: 40% 60%;">
						<div class="col" style="justify-items: center;">
							<p>An RVE made of 4 materials</p>
							<img data-src="assets/homogenization.svg" style="height: 280px;">
							<div style="font-size: 1.5rem;">
								\[
								\begin{aligned}
								F_{xx} &= 1 + 0.1 \sin(20 t) + 0.1 \cos(15 t)\\
								P_{xy} &= 100 \sin(13 t) + 150 \cos(9 t)\\
								F_{yx} &= 0\\
								P_{yy} &= -70 \sin(9 t) - 130 \cos(25 t)
								\end{aligned}
								\]
							</div>
						</div>
						<div class="col">
							<video controls style="height: 500px; margin: auto; display: inline-block;">
								<source data-src="/assets/homogenization.webm" type="video/webm" />
							</video>
						</div>
					</div>
				</section>
			</section>
		</div>
	</div>

	<script src="dist/reveal.js"></script>
	<script src="plugin/notes/notes.js"></script>
	<script src="plugin/markdown/markdown.js"></script>
	<script src="plugin/highlight/highlight.js"></script>
	<script src="plugin/math/math.js"></script>
	<script>
		// More info about initialization & config:
		// - https://revealjs.com/initialization/
		// - https://revealjs.com/config/
		Reveal.initialize({
			width: 1280,
			height: 720,
			transitionSpeed: "default",
			pdfSeparateFragments: false,
			hash: true,
			// Learn about plugins: https://revealjs.com/plugins/
			plugins: [RevealMarkdown, RevealHighlight, RevealNotes, RevealMath.MathJax3]
		});
	</script>
</body>

</html>
